# Architecture

**Analysis Date:** 2026-02-10

## Pattern Overview

**Overall:** GSD Project Framework (No application codebase yet)

**Key Characteristics:**
- Project structure is GSD (Get Shit Done) framework initialization
- No application-specific code layer exists yet
- Framework provides scaffolding for phase-based development workflow
- Extensible agent-based architecture for project planning and execution

## Layers

**GSD Framework Layer:**
- Purpose: Provides CLI tools, agents, and workflows for project management and code generation
- Location: `.claude/get-shit-done/`, `.claude/agents/`, `.claude/commands/`
- Contains: Agent definitions, command workflows, templates, state management tools
- Depends on: Node.js runtime, markdown parsing, git integration
- Used by: All future phases will reference framework tools via CLI commands

**CLI Tools Layer:**
- Purpose: Centralized utilities for state management, phase operations, git commits, configuration
- Location: `.claude/get-shit-done/bin/gsd-tools.js`
- Contains: State CRUD operations, phase management, roadmap parsing, validation utilities
- Depends on: File system, JSON parsing, command-line argument processing
- Used by: All agents and workflows for consistent state mutations

**Agent System:**
- Purpose: Specialized Claude instances spawned for specific workflow steps
- Location: `.claude/agents/*.md`
- Contains: Agent role definitions, tools, process documentation
- Depends on: Claude API, context passing via markdown frontmatter
- Used by: Orchestrator (implied) to delegate work tasks

**Command/Workflow Layer:**
- Purpose: User-facing command definitions and corresponding workflows
- Location: `.claude/commands/gsd/*.md`, `.claude/get-shit-done/workflows/*.md`
- Contains: Workflow instructions, parameter parsing, agent spawning logic
- Depends on: Agent definitions, tools layer, state management
- Used by: User invokes via `/gsd:*` commands

**Planning State Layer:**
- Purpose: Persistent storage of project roadmap, phases, milestones, decisions
- Location: `.planning/` directory (currently empty)
- Contains: ROADMAP.md, STATE.md, phase directories, milestone archives
- Depends on: Markdown file format, frontmatter YAML parsing
- Used by: All tools for reading/updating project state

## Data Flow

**Phase Creation Flow:**

1. User invokes `/gsd:new-project` or `/gsd:add-phase`
2. Command workflow reads current state from `.planning/ROADMAP.md` and `.planning/STATE.md`
3. Agent (gsd-roadmapper or gsd-planner) generates phase description and planning docs
4. gsd-tools.js creates phase directory under `.planning/1.0/`, `.planning/2.0/`, etc.
5. Phase directory contains PLAN.md(s), CONTEXT.md, and associated artifacts
6. State is committed to git with phase metadata

**Execution Flow:**

1. User invokes `/gsd:execute-phase` with phase number
2. gsd-executor agent reads PLAN.md from phase directory
3. Executor spawns gsd-codebase-mapper or specialized agents based on phase type
4. Agents write code/documentation directly to application directories
5. Upon completion, gsd-verifier checks artifacts and generates SUMMARY.md
6. Summary is committed; phase marked complete in STATE.md

**State Management:**
- All state is stored in markdown files (ROADMAP.md, STATE.md, phase PODs)
- gsd-tools.js provides atomic CRUD operations on STATE.md via text parsing
- Git commits track all state changes with consistent message format
- No databaseâ€”filesystem is source of truth

## Key Abstractions

**Phase:**
- Purpose: Represents a unit of work with specific deliverables and tests
- Examples: `.planning/1.0/PLAN.md`, `.planning/1.5/PLAN.md`, `.planning/2.0/`
- Pattern: Decimal numbering (1.0, 1.1, 1.2, 2.0, 2.1, etc.) for phase hierarchy

**Wave:**
- Purpose: Subdivision within a phase plan, allows incremental delivery
- Examples: Wave 1, Wave 2 within a single PLAN.md
- Pattern: Numbered sections in PLAN.md with individual deliverables

**Task:**
- Purpose: Atomic unit of work within a wave
- Examples: Scaffolding code, writing tests, creating database schema
- Pattern: Individual checklist items within wave sections in PLAN.md

**Artifact:**
- Purpose: Deliverable produced by phase execution
- Examples: Source files, configuration, documentation, test results
- Pattern: Files in application directories specified in must_haves.artifacts

**CONTEXT.md:**
- Purpose: Captures user requirements, constraints, and assumptions for a phase
- Examples: `.planning/1.0/CONTEXT.md`, `.planning/2.1/CONTEXT.md`
- Pattern: Generated by agents, contains user stories, acceptance criteria, dependencies

**PLAN.md:**
- Purpose: Implementation roadmap with tasks, test requirements, verification criteria
- Examples: `.planning/1.0/PLAN.md`, `.planning/1.0/PLAN.1.md` (multiple plans per phase)
- Pattern: Frontmatter metadata + markdown sections organized by wave

**SUMMARY.md:**
- Purpose: Post-execution report of what was built, decisions made, metrics
- Examples: `.planning/1.0/SUMMARY.md` (created after execution completes)
- Pattern: Structured markdown with commit hashes, file paths, code samples

## Entry Points

**CLI Commands:**
- Location: Invoked via `/gsd:*` syntax (e.g., `/gsd:execute-phase`, `/gsd:map-codebase`)
- Triggers: User text input in Claude interface
- Responsibilities: Parse arguments, load state, spawn appropriate agent, manage git commits

**Agent Spawning:**
- Location: Workflows in `.claude/get-shit-done/workflows/*.md` invoke agents
- Triggers: Command execution, phase transitions, post-execution verification
- Responsibilities: Set agent context, pass state snapshots, handle agent output

**gsd-tools.js CLI:**
- Location: `.claude/get-shit-done/bin/gsd-tools.js`
- Triggers: Invoked by agents/workflows via bash
- Responsibilities: Atomic state mutations, phase operations, validation, scaffolding

## Error Handling

**Strategy:** Fail-fast with clear error messages; all operations are idempotent where possible

**Patterns:**
- Phase operations validate that phase directories exist before mutation
- State updates check for required fields before writing
- Git operations abort if uncommitted changes exist (unless --force)
- Path validation before file operations (verify-path-exists command)
- Frontmatter validation against schemas (plan, summary, verification)

## Cross-Cutting Concerns

**Logging:** Structured output via CLI; agents log to markdown frontmatter metadata sections

**Validation:** Schema validation via gsd-tools.js (frontmatter schemas, plan structure, artifact references)

**Authentication:** Git authentication via local SSH keys; Claude API key managed by Claude environment

**State Consistency:** Validation command checks phase numbering, disk/roadmap sync, reference integrity
